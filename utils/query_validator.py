"""
Query Validation Utilities for RAG Service

This module provides security and validation functions for SQL queries
generated by the RAG service to prevent malicious queries and ensure
data integrity.
"""

import re
import logging
from typing import List, Dict, Any, Tuple
from utils.rag_config import ALLOWED_SQL_KEYWORDS, FORBIDDEN_SQL_KEYWORDS, FORBIDDEN_PATTERNS

logger = logging.getLogger(__name__)

class QueryValidator:
    """Validator for SQL queries generated by the RAG service."""
    
    def __init__(self):
        self.allowed_keywords = [kw.upper() for kw in ALLOWED_SQL_KEYWORDS]
        self.forbidden_keywords = [kw.upper() for kw in FORBIDDEN_SQL_KEYWORDS]
    
    def validate_query(self, query: str) -> Tuple[bool, str]:
        """
        Validate a SQL query for security and correctness.
        
        Args:
            query: SQL query string to validate
            
        Returns:
            Tuple of (is_valid, error_message)
        """
        try:
            # Basic sanitization
            query = query.strip()
            
            if not query:
                return False, "Query is empty"
            
            # Convert to uppercase for keyword checking
            query_upper = query.upper()
            
            # Check for forbidden keywords (using word boundaries to avoid false positives)
            for keyword in self.forbidden_keywords:
                # Use word boundary regex to match complete words only
                pattern = r'\b' + re.escape(keyword) + r'\b'
                if re.search(pattern, query_upper):
                    return False, f"Forbidden keyword detected: {keyword}"
            
            # Check if query starts with SELECT
            if not query_upper.strip().startswith("SELECT"):
                return False, "Query must start with SELECT"
            
            # Check for basic SQL injection patterns
            injection_patterns = [
                r";\s*--",  # Comment injection
                r";\s*DROP",  # Drop table injection
                r";\s*DELETE",  # Delete injection
                r";\s*INSERT",  # Insert injection
                r";\s*UPDATE",  # Update injection
                r"UNION\s+SELECT",  # Union injection
                r"LOAD_FILE\s*\(",  # File access
                r"INTO\s+OUTFILE",  # File output
                r"EXEC\s*\(",  # Execution
                r"SYSTEM\s*\(",  # System calls
            ]
            
            for pattern in injection_patterns:
                if re.search(pattern, query_upper):
                    return False, f"Potentially malicious pattern detected: {pattern}"
            
            # Check for balanced parentheses
            if query.count('(') != query.count(')'):
                return False, "Unbalanced parentheses in query"
            
            # Check for reasonable length
            if len(query) > 2000:
                return False, "Query is too long"
            
            # Validate table names (basic check)
            valid_tables = [
                'users', 'players', 'teams', 'games', 'player_evaluations',
                'player_game_stats', 'metrics', 'player_assessments',
                'player_teams', 'player_videos', 'videos', 'player_documents',
                'classes', 'roles', 'core_values', 'programs'
            ]
            
            # Extract table names from FROM and JOIN clauses
            table_pattern = r'(?:FROM|JOIN)\s+([a-zA-Z_][a-zA-Z0-9_]*)'
            found_tables = re.findall(table_pattern, query, re.IGNORECASE)
            
            for table in found_tables:
                if table.lower() not in valid_tables:
                    return False, f"Invalid table name: {table}"
            
            return True, "Query is valid"
            
        except Exception as e:
            logger.error(f"Error validating query: {e}")
            return False, f"Validation error: {str(e)}"
    
    def sanitize_query(self, query: str) -> str:
        """
        Sanitize a query by removing potentially harmful elements.
        
        Args:
            query: SQL query to sanitize
            
        Returns:
            Sanitized query string
        """
        # Remove comments
        query = re.sub(r'--.*$', '', query, flags=re.MULTILINE)
        query = re.sub(r'/\*.*?\*/', '', query, flags=re.DOTALL)
        
        # Remove extra whitespace
        query = re.sub(r'\s+', ' ', query).strip()
        
        # Ensure query ends with semicolon
        if not query.endswith(';'):
            query += ';'
        
        return query
    
    def add_safety_limits(self, query: str, max_results: int = 100) -> str:
        """
        Add safety limits to a query if not already present.
        
        Args:
            query: SQL query
            max_results: Maximum number of results to return
            
        Returns:
            Query with safety limits added
        """
        query_upper = query.upper()
        
        # Add LIMIT if not present
        if 'LIMIT' not in query_upper:
            # Remove semicolon if present
            if query.endswith(';'):
                query = query[:-1]
            query += f' LIMIT {max_results};'
        
        return query

class QueryAnalyzer:
    """Analyzer for understanding query intent and complexity."""
    
    def analyze_query(self, query: str) -> Dict[str, Any]:
        """
        Analyze a SQL query to understand its intent and complexity.
        
        Args:
            query: SQL query to analyze
            
        Returns:
            Dictionary containing analysis results
        """
        analysis = {
            "tables_used": [],
            "joins_count": 0,
            "has_aggregation": False,
            "has_subquery": False,
            "complexity_score": 0,
            "estimated_cost": "low"
        }
        
        try:
            query_upper = query.upper()
            
            # Extract table names
            table_pattern = r'(?:FROM|JOIN)\s+([a-zA-Z_][a-zA-Z0-9_]*)'
            analysis["tables_used"] = re.findall(table_pattern, query, re.IGNORECASE)
            
            # Count joins
            join_pattern = r'\bJOIN\b'
            analysis["joins_count"] = len(re.findall(join_pattern, query_upper))
            
            # Check for aggregation functions
            agg_functions = ['COUNT', 'SUM', 'AVG', 'MAX', 'MIN', 'GROUP BY']
            analysis["has_aggregation"] = any(func in query_upper for func in agg_functions)
            
            # Check for subqueries
            analysis["has_subquery"] = '(' in query and 'SELECT' in query.split('(', 1)[1]
            
            # Calculate complexity score
            complexity = 0
            complexity += len(analysis["tables_used"]) * 2
            complexity += analysis["joins_count"] * 3
            complexity += 5 if analysis["has_aggregation"] else 0
            complexity += 10 if analysis["has_subquery"] else 0
            
            analysis["complexity_score"] = complexity
            
            # Estimate cost
            if complexity <= 5:
                analysis["estimated_cost"] = "low"
            elif complexity <= 15:
                analysis["estimated_cost"] = "medium"
            else:
                analysis["estimated_cost"] = "high"
            
        except Exception as e:
            logger.error(f"Error analyzing query: {e}")
        
        return analysis

# Create singleton instances
query_validator = QueryValidator()
query_analyzer = QueryAnalyzer()
